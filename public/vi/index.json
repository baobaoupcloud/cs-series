[
{
	"uri": "//localhost:1313/vi/1-data-structures/",
	"title": "Cấu trúc dữ liệu",
	"tags": [],
	"description": "",
	"content": "Cấu trúc dữ liệu về cơ bản là các hình thức tổ chức trong bộ nhớ. Có nhiều cách để tổ chức dữ liệu trong bộ nhớ. Cấu trúc dữ liệu trừu tượng là những cấu trúc mà chúng ta có thể tưởng tượng một cách khái niệm. Khi học về khoa học máy tính, bắt đầu với việc học những cấu trúc này sẽ giúp dễ dàng hơn trong việc hiểu cách triển khai các cấu trúc dữ liệu cụ thể hơn sau này.\n"
},
{
	"uri": "//localhost:1313/vi/",
	"title": "CS50 Tuần 5",
	"tags": [],
	"description": "",
	"content": "CS50 Tuần 5 - Cấu trúc dữ liệu Tổng quan Chào mừng đến với tuần thứ 5. Ở tuần này, chúng ta sẽ bàn về cách sắp xếp dữ liệu trong bộ nhớ.\nMục lục Cấu trúc dữ liệu Hàng đợi và Ngăn xếp Thay đổi kích thước mảng Danh sách liên kết Cây Từ điển Cây tiền tố "
},
{
	"uri": "//localhost:1313/vi/2-stacks-and-queues/",
	"title": "Hàng đợi và Ngăn xếp",
	"tags": [],
	"description": "",
	"content": "Queues - Hàng đợi Queues là một dạng cấu trúc dữ liệu trừu tượng.\nQueues có những đặc tính cụ thể. Đó là FIFO hay \u0026ldquo;first in first out\u0026rdquo; (đến trước, phục vụ trước). Hãy tưởng tượng bạn đang xếp hàng để mua kem, người đứng đầu hàng sẽ nhận kem trước. Người đứng cuối hàng sẽ là người nhận kem cuối cùng.\nQueues có những tác vụ cụ thể liên quan. Ví dụ, một mục có thể được enqueued, có nghĩa là mục đó có thể gia nhập vào hàng đợi. Ngoài ra, một mục có thể được dequeued hoặc rời khỏi hàng đợi khi nó đến lượt ở đầu hàng.\nStacks - Ngăn xếp Stacks có những đặc tính ngược lại với queues. Cụ thể, stacks có tính chất LIFO hay \u0026ldquo;last in first out\u0026rdquo; (đến sau, phục vụ trước). Giống như việc xếp đĩa trong một căng tin, đĩa được đặt vào ngăn xếp cuối cùng sẽ là đĩa đầu tiên được lấy ra.\nStacks cũng có những tác vụ cụ thể liên quan. Ví dụ, push là đặt một mục lên trên cùng của ngăn xếp. Pop là loại bỏ một mục từ phía trên cùng ngăn xếp.\nCó thể tưởng tượng một cấu trúc stack được định nghĩa như sau:\ntypedef struct{ person people[CAPACITY]; int size; } stack; Giải thích: định nghĩa một mảng people có kiểu person. CAPACITY là dung lượng tối đa của stack. Số nguyên size là mức độ đầy của stack, bất kể nó có thể chứa bao nhiêu.\nChúng ta có thể hiểu rằng mã trên có một số giới hạn. Bởi vì dung lượng của mảng luôn được xác định trước trong mã này nên stack có thể luôn bị thừa. Chúng ta có thể chỉ sử dụng một chỗ trong stack trong tổng số 5000.\nSẽ tốt hơn nếu stack động – có khả năng mở rộng khi có các mục được thêm vào.\n"
},
{
	"uri": "//localhost:1313/vi/3-resizing-arrays/",
	"title": "Thay đổi kích thước mảng",
	"tags": [],
	"description": "",
	"content": "Hãy tưởng tượng chúng ta có một mảng gồm 3 số 1, 2, 3. Trong bộ nhớ, còn có nhiều giá trị khác đang được lưu trữ bởi các chương trình, hàm và biến khác. Nhiều giá trị trong số này có thể là các giá trị rác chưa được sử dụng hay từng được sử dụng ở một thời điểm nào đó nhưng hiện tại có sẵn để sử dụng.\nGiả sử chúng ta muốn lưu trữ một giá trị thứ tư là 4 trong mảng. Chúng ta cần phải cấp phát một vùng bộ nhớ mới và di chuyển mảng cũ sang vùng mới này. Ban đầu, vùng bộ nhớ mới sẽ được lấp đầy bằng các giá trị rác.\nKhi các giá trị được thêm vào vùng bộ nhớ mới, các giá trị rác cũ sẽ bị ghi đè.\nMột trong những nhược điểm của cách tiếp cận này là thiết kế không tối ưu. Mỗi khi chúng ta thêm một số, chúng ta phải sao chép từng phần tử của mảng.\nDựa trên những kiến thức đã học ở các tuần trước, chúng ta có thể tận dụng con trỏ để tối ưu thiết kế. Trong terminal, gõ code list.c và viết mã như sau:\n// Tạo một danh sách các số với mảng có kích thước động #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { // Danh sách có kích thước 3 int *list = malloc(3 * sizeof(int)); if (list == NULL) { return 1; } // Gán danh sách với các số list[0] = 1; list[1] = 2; list[2] = 3; // Tạo danh sách có kích thước 4 int *tmp = malloc(4 * sizeof(int)); if (tmp == NULL) { free(list); return 1; } // Sao chép danh sách kích thước 3 vào danh sách kích thước 4 for (int i = 0; i \u0026lt; 3; i++) { tmp[i] = list[i]; } // Thêm số mới vào danh sách kích thước 4 tmp[3] = 4; // Giải phóng danh sách kích thước 3 free(list); // Nhớ danh sách kích thước 4 list = tmp; // In danh sách for (int i = 0; i \u0026lt; 4; i++) { printf(\u0026#34;%i\\n\u0026#34;, list[i]); } // Giải phóng danh sách free(list); return 0; } Giải thích: một danh sách có kích thước ba số nguyên được tạo ra. Sau đó, ba địa chỉ bộ nhớ được gán các giá trị 1, 2, và 3. Tiếp theo, một danh sách có kích thước bốn được tạo ra. Danh sách cũ được sao chép sang danh sách mới. Giá trị 4 được thêm vào danh sách tmp. Vì khối bộ nhớ mà list trỏ tới không còn được sử dụng, nó sẽ được giải phóng bằng lệnh free(list). Cuối cùng, chúng ta cập nhật con trỏ list để trỏ tới khối bộ nhớ mà tmp đang trỏ tới. Nội dung của list được in ra và sau đó cũng được giải phóng.\n"
},
{
	"uri": "//localhost:1313/vi/4-linked-lists/",
	"title": "Danh sách liên kết",
	"tags": [],
	"description": "",
	"content": "Linked list (danh sách liên kết) là một trong những cấu trúc dữ liệu mạnh mẽ nhất trong C. Nó cho phép chúng ta lưu trữ các giá trị nằm ở những vùng bộ nhớ khác nhau. Hơn nữa, linked list cho phép chúng ta mở rộng hoặc thu nhỏ danh sách một cách linh hoạt theo từng nhu cầu.\nChúng ta sẽ sử dụng các phần tử cơ bản sau:\nstruct là kiểu dữ liệu mà chúng ta có thể tự định nghĩa. . cho phép truy cập các biến bên trong cấu trúc đó. * được sử dụng để khai báo một con trỏ hoặc giải tham chiếu một biến. -\u0026gt; giúp truy cập vào một địa chỉ và đi vào bên trong một cấu trúc. Hãy tưởng tượng ba giá trị được lưu trữ tại ba vùng bộ nhớ khác nhau như sau:\nĐể kết nối các giá trị này thành một danh sách, chúng ta có thể sử dụng thêm bộ nhớ để theo dõi vị trí của mục tiếp theo.\nNULL được sử dụng để chỉ ra rằng không còn gì khác trong danh sách.\nTheo quy ước, chúng ta sẽ giữ một phần tử bổ sung trong bộ nhớ, đó là một con trỏ, dùng để theo dõi mục đầu tiên trong danh sách.\nBỏ qua các địa chỉ bộ nhớ, danh sách sẽ xuất hiện như sau:\nCác ô này được gọi là nodes. Một node chứa một item và một con trỏ gọi là next. Trong mã, chúng ta có thể tưởng tượng một node như sau:\ntypedef struct node { int number; struct node *next; } node; Phần tử chứa trong node này là một số nguyên có tên là number. Thứ hai, nó bao gồm một con trỏ tới một node khác gọi là next, sẽ trỏ tới một node nào đó trong bộ nhớ.\nVề mặt khái niệm, chúng ta có thể hình dung quá trình tạo một linked list như sau. Đầu tiên, node *list được khai báo, nhưng nó sẽ có giá trị rác.\nTiếp theo, một node gọi là n được cấp phát trong bộ nhớ.\nSau đó, giá trị number của node n được gán là 1.\nTiếp theo, trường next của node được gán là NULL.\nSau đó, list được trỏ tới địa chỉ mà n đang trỏ tới. Bây giờ, n và list đều trỏ tới cùng một vị trí.\nMột node mới sau đó được tạo ra. Cả trường number và next đều được lấp đầy bằng các giá trị rác.\nGiá trị number của node n (node mới) được cập nhật thành 2.\nTrường next lúc này cũng được cập nhật.\nQuan trọng nhất, chúng ta không muốn mất kết nối với bất kỳ node nào trong số này để không bị lạc mất. Do đó, trường next của n được trỏ tới cùng một địa chỉ bộ nhớ như list.\nCuối cùng, list được cập nhật để trỏ tới n. Chúng ta đã có một linked list gồm hai mục.\nĐể triển khai điều này trong mã, hãy viết code list.c như sau:\n// Tạo một danh sách các số sử dụng linked list #include \u0026lt;cs50.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct node { int number; struct node *next; } node; int main(int argc, char *argv[]) { // Bộ nhớ cho các số node *list = NULL; // Đối với mỗi tham số dòng lệnh for (int i = 1; i \u0026lt; argc; i++) { // Chuyển đổi tham số thành int int number = atoi(argv[i]); // Cấp phát node cho số node *n = malloc(sizeof(node)); if (n == NULL) { return 1; } n-\u0026gt;number = number; n-\u0026gt;next = NULL; // Nếu danh sách rỗng if (list == NULL) { // Node này là toàn bộ danh sách list = n; } // Nếu danh sách đã có số else { // Lặp qua các node trong danh sách for (node *ptr = list; ptr != NULL; ptr = ptr-\u0026gt;next) { // Nếu ở cuối danh sách if (ptr-\u0026gt;next == NULL) { // Thêm node ptr-\u0026gt;next = n; break; } } } } // In các số for (node *ptr = list; ptr != NULL; ptr = ptr-\u0026gt;next) { printf(\u0026#34;%i\\n\u0026#34;, ptr-\u0026gt;number); } // Giải phóng bộ nhớ node *ptr = list; while (ptr != NULL) { node *next = ptr-\u0026gt;next; free(ptr); ptr = next; } } Chú ý rằng những gì người dùng nhập vào dòng lệnh sẽ được đưa vào trường number của node gọi là n, và sau đó node đó sẽ được thêm vào list. Ví dụ, gõ lệnh ./list 1 2 sẽ đưa số 1 vào trường number của node gọi là n, sau đó sẽ đặt một con trỏ tới list vào trường next của node, và cập nhật list để trỏ tới n. Quá trình này sẽ được lặp lại cho số 2. Tiếp theo, node *ptr = list tạo ra một biến tạm thời trỏ tới cùng một vị trí mà list trỏ tới. Vòng lặp while sẽ in ra nội dung của node mà ptr trỏ tới và sau đó cập nhật ptr để trỏ tới node tiếp theo trong danh sách. Cuối cùng, tất cả bộ nhớ sẽ được giải phóng.\nLinked lists không được lưu trữ trong một khối bộ nhớ liên tiếp. Chúng có thể mở rộng lớn hơn tùy ý, miễn là có đủ tài nguyên hệ thống. Tuy nhiên, nhược điểm là cần nhiều bộ nhớ hơn để theo dõi danh sách thay vì một mảng. Chúng ta không chỉ phải lưu giá trị của phần tử mà còn phải lưu một con trỏ tới node tiếp theo.\nHơn nữa, linked lists không thể được truy cập theo chỉ số như trong một mảng vì chúng ta cần phải đi qua n−1 phần tử đầu tiên để tìm vị trí của phần tử thứ n. Do đó, danh sách như hình trên phải được tìm kiếm tuần tự, không thể tìm kiếm nhị phân.\nChúng ta có thể tạo một danh sách được sắp xếp trong khi các mục được thêm vào:\n// Tạo một danh sách được sắp xếp các số sử dụng linked list #include \u0026lt;cs50.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct node { int number; // Số nguyên struct node *next; // Con trỏ tới node tiếp theo } node; int main(int argc, char *argv[]) { // Bộ nhớ cho các số node *list = NULL; // Đối với mỗi tham số dòng lệnh for (int i = 1; i \u0026lt; argc; i++) { // Chuyển đổi tham số thành int int number = atoi(argv[i]); // Cấp phát node cho số node *n = malloc(sizeof(node)); if (n == NULL) { return 1; // Nếu không đủ bộ nhớ, trả về 1 } n-\u0026gt;number = number; // Gán giá trị cho trường number n-\u0026gt;next = NULL; // Khởi tạo trường next là NULL // Nếu danh sách rỗng if (list == NULL) { list = n; // Node này là toàn bộ danh sách } // Nếu số thuộc về đầu danh sách else if (n-\u0026gt;number \u0026lt; list-\u0026gt;number) { n-\u0026gt;next = list; // Đặt node mới vào đầu danh sách list = n; // Cập nhật list trỏ tới node mới } // Nếu số thuộc về vị trí sau trong danh sách else { // Lặp qua các node trong danh sách for (node *ptr = list; ptr != NULL; ptr = ptr-\u0026gt;next) { // Nếu ở cuối danh sách if (ptr-\u0026gt;next == NULL) { ptr-\u0026gt;next = n; // Thêm node vào cuối danh sách break; } // Nếu ở giữa danh sách if (n-\u0026gt;number \u0026lt; ptr-\u0026gt;next-\u0026gt;number) { n-\u0026gt;next = ptr-\u0026gt;next; // Đặt con trỏ tới node tiếp theo ptr-\u0026gt;next = n; // Chèn node mới vào giữa break; } } } } // In các số for (node *ptr = list; ptr != NULL; ptr = ptr-\u0026gt;next) { printf(\u0026#34;%i\\n\u0026#34;, ptr-\u0026gt;number); // In ra số ở node hiện tại } // Giải phóng bộ nhớ node *ptr = list; while (ptr != NULL) { node *next = ptr-\u0026gt;next; // Lưu trữ node tiếp theo free(ptr); // Giải phóng node hiện tại ptr = next; // Cập nhật ptr tới node tiếp theo } } "
},
{
	"uri": "//localhost:1313/vi/5-trees/",
	"title": "Cây",
	"tags": [],
	"description": "",
	"content": "Tree - Cây tìm kiếm nhị phân là một cấu trúc dữ liệu khác có thể được sử dụng để lưu trữ dữ liệu một cách hiệu quả hơn, giúp dễ dàng tìm kiếm và truy xuất.\nChúng ta có thể tưởng tượng một chuỗi số đã được sắp xếp.\nHãy tưởng tượng rằng giá trị ở giữa trở thành đỉnh của cây. Những giá trị nhỏ hơn sẽ được đặt ở bên trái, còn những giá trị lớn hơn sẽ ở bên phải.\nCác con trỏ có thể được sử dụng để chỉ đến đúng vị trí của từng khu vực bộ nhớ, để mỗi node này có thể được kết nối với nhau.\nTrong mã, cấu trúc này có thể được triển khai như sau:\n// Tạo danh sách các số dưới dạng cây tìm kiếm nhị phân #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Đại diện cho một node typedef struct node { int number; // Giá trị số struct node *left; // Con trỏ đến node bên trái struct node *right; // Con trỏ đến node bên phải } node; void free_tree(node *root); // Hàm giải phóng bộ nhớ cho cây void print_tree(node *root); // Hàm in ra cây int main(void) { // Cây có kích thước 0 node *tree = NULL; // Thêm số vào danh sách node *n = malloc(sizeof(node)); if (n == NULL) { return 1; // Nếu không đủ bộ nhớ, trả về 1 } n-\u0026gt;number = 2; // Gán giá trị cho node n-\u0026gt;left = NULL; // Khởi tạo con trỏ bên trái là NULL n-\u0026gt;right = NULL; // Khởi tạo con trỏ bên phải là NULL tree = n; // Cập nhật cây // Thêm số vào danh sách n = malloc(sizeof(node)); if (n == NULL) { free_tree(tree); // Giải phóng bộ nhớ nếu không đủ return 1; } n-\u0026gt;number = 1; // Gán giá trị cho node n-\u0026gt;left = NULL; // Khởi tạo con trỏ bên trái là NULL n-\u0026gt;right = NULL; // Khởi tạo con trỏ bên phải là NULL tree-\u0026gt;left = n; // Đặt node này làm node bên trái của cây // Thêm số vào danh sách n = malloc(sizeof(node)); if (n == NULL) { free_tree(tree); // Giải phóng bộ nhớ nếu không đủ return 1; } n-\u0026gt;number = 3; // Gán giá trị cho node n-\u0026gt;left = NULL; // Khởi tạo con trỏ bên trái là NULL n-\u0026gt;right = NULL; // Khởi tạo con trỏ bên phải là NULL tree-\u0026gt;right = n; // Đặt node này làm node bên phải của cây // In cây print_tree(tree); // Giải phóng cây free_tree(tree); return 0; } void free_tree(node *root) { if (root == NULL) { return; // Nếu node là NULL, không làm gì cả } free_tree(root-\u0026gt;left); // Giải phóng cây bên trái free_tree(root-\u0026gt;right); // Giải phóng cây bên phải free(root); // Giải phóng node hiện tại } void print_tree(node *root) { if (root == NULL) { return; // Nếu node là NULL, không làm gì cả } print_tree(root-\u0026gt;left); // In cây bên trái printf(\u0026#34;%i\\n\u0026#34;, root-\u0026gt;number); // In ra giá trị số tại node hiện tại print_tree(root-\u0026gt;right); // In cây bên phải } Giải thích: hàm tìm kiếm bắt đầu bằng cách đi đến vị trí của tree. Sau đó, nó sử dụng đệ quy để tìm kiếm number. Hàm free_tree sẽ giải phóng cây theo cách đệ quy. Hàm print_tree cũng thực hiện việc in cây theo cách đệ quy.\nMột cây như trên mang lại tính linh hoạt mà một mảng không có. Nó có thể tăng lên và thu nhỏ theo nhu cầu của chúng ta. Hơn nữa, cấu trúc này còn có thể được tìm kiếm nhanh.\n"
},
{
	"uri": "//localhost:1313/vi/6-dictionaries/",
	"title": "Từ điển",
	"tags": [],
	"description": "",
	"content": "Dictionary - Từ điển Từ điển là một cấu trúc dữ liệu khác. Giống như từ điển nghĩa đen, có từ và định nghĩa, nó có một khóa và một giá trị.\nKhóa thường có thể thuộc nhiều loại khác nhau (chuỗi, số,\u0026hellip;), và giá trị có thể là bất kỳ loại dữ liệu nào. Mỗi khóa là duy nhất và được sử dụng để truy xuất giá trị liên quan.\nTừ điển có thể cung cấp tốc độ truy cập nhanh nhờ vào hash (băm).\nHash - Băm Băm là việc lấy một giá trị và xuất ra một giá trị khác chính là lối tắt cho nó sau này.\nVí dụ, từ táo có thể băm thành giá trị 1, và chanh có thể được băm thành 2. Từ đó, việc tìm táo sẽ dễ như việc hỏi thuật toán hash nơi mà 1 được lưu trữ. Một giá trị đã được băm có thể được sử dụng như một lối tắt để tìm giá trị đó.\nMột hàm băm là một thuật toán biến một giá trị lớn thành một thứ nhỏ hơn và có thể dự đoán được. Thông thường, hàm này sẽ nhận một mục mà chúng ta muốn thêm vào bảng băm và trả về một số nguyên đại diện cho chỉ số mảng nơi mà mục đó nên được đặt.\nMột bảng băm là sự kết hợp giữa mảng và danh sách liên kết. Khi được triển khai trong mã, một bảng băm là một mảng của các con trỏ đến các node.\nMột bảng băm có thể được tưởng tượng như sau:\nĐây là một mảng được gán cho mỗi giá trị của bảng chữ cái.\nSau đó, tại mỗi vị trí của mảng, một danh sách liên kết được sử dụng để theo dõi mỗi giá trị được lưu trữ ở đó:\nMâu thuẫn sẽ xảy ra khi ta thêm giá trị vào bảng băm một cái gì đó đã tồn tại trước vị trí đã băm. Trong trường hợp này, các va chạm sẽ được thêm vào cuối danh sách.\nĐiều này có thể được giảm thiểu bằng cách lập trình bảng băm và thuật toán băm tối ưu hơn như sau:\nChúng ta phải cân nhắc chọn giữa sử dụng nhiều bộ nhớ hơn để có một bảng băm lớn và có khả năng giảm thời gian tìm kiếm, hoặc sử dụng ít bộ nhớ hơn và có khả năng tăng thời gian tìm kiếm.\n"
},
{
	"uri": "//localhost:1313/vi/7-tries/",
	"title": "Cây tiền tố",
	"tags": [],
	"description": "",
	"content": "Trie (cây tiền tố) là một dạng cấu trúc dữ liệu khác được sử dụng để lưu trữ một tập hợp chuỗi động. Trie luôn có thể tìm kiếm trong khoảng thời gian xác định. Nó đặc biệt hiệu quả cho các tác vụ như tìm kiếm tiền tố và tự động hoàn thành.\nMột nhược điểm của Trie là chúng thường chiếm nhiều bộ nhớ.\nVí dụ từ Toad sẽ được lưu trữ như sau:\nToad được đánh vần từng chữ cái một, trong đó mỗi chữ cái được liên kết với một danh sách: T từ một danh sách, O từ một danh sách khác, và cứ như vậy.\nLưu ý rằng chúng ta cần tới 26 x 4 = 104 node chỉ để lưu trữ Toad.\nVà đó là kết thúc của tuần 5 ^^\n"
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]