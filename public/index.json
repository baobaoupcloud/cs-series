[
{
	"uri": "//localhost:1313/",
	"title": "CS50 Week 5",
	"tags": [],
	"description": "",
	"content": "CS50 Week 5 - Data Structure Overall Welcome to week 5. On this week, we are going to talk about organizing data in memory. We will go through these following contents.\nContent Data Structures Stacks and Queues Resizing Arrays Linked Lists Trees Dictionaries Tries "
},
{
	"uri": "//localhost:1313/1-data-structures/",
	"title": "Data Structures",
	"tags": [],
	"description": "",
	"content": "Data structures essentially are forms of organization in memory. There are many ways to organize data in memory. Abstract data structures are those that we can conceptually imagine. When learning about computer science, it’s often useful to begin with these conceptual data structures. Learning these will make it easier later to understand how to implement more concrete data structures.\n"
},
{
	"uri": "//localhost:1313/2-stacks-and-queues/",
	"title": "Stacks and Queues",
	"tags": [],
	"description": "",
	"content": "Queues Queues are one form of abstract data structure.\nQueues have specific properties. Namely, they are FIFO or “first in first out.” Imagine in a line waiting to buy ice-cream, the first person in the line gets the ice-cream first. The last person is the last to get ice-cream.\nQueues have specific actions associated with them. For example, an item can be enqueued. It means, the item can join the line or queue. Further, an item can be dequeued or leave the queue once it reaches the front of the line.\nStacks Stacks are contrast to queues. Specifically, stacks have the properties of LIFO or “last in first out.” Just like stacking trays in a cafeteria, a tray that is placed in a stack last is the first that may be picked up.\nStacks have specific actions associated with them. For example, push places something on top of a stack. Pop is removing something from the top of the stack.\nIn code, we might imagine a stack structure defined as follows:\ntypedef struct{ person people[CAPACITY]; int size; } stack; Notice that an array called people is of type person. The CAPACITY is how high the stack could be. The integer size is how full the stack actually is, regardless of how much it could hold.\nWe might imagine that the above code has a limitation. Since the capacity of the array is always predetermined in this code. Therefore, the stack may always be oversized. We might imagine only using one place in the stack out of 5000.\nIt would be nice for our stack to be dynamic – able to grow as items are added to it.\n"
},
{
	"uri": "//localhost:1313/3-resizing-arrays/",
	"title": "Resizing Arrays",
	"tags": [],
	"description": "",
	"content": "Imagine we have an array of 3 numbers 1, 2, 3. In memory, there are other values being stored by other programs, functions, and variables. Many of these may be unused garbage values that were utilized at one point but are available now for use.\nImagine we wanted to store a fourth value 4in our array? What would be needed is to allocate a new area of memory and move the old array to a new one. Initially, this new area of memory would be populated with garbage values.\nAs values are added to this new area of memory, old garbage values would be overwritten.\nOne of the drawbacks of this approach is that it’s bad design: Every time we add a number, we have to copy the array item by item.\nBuilding upon our knowledge obtained in previous weeks, we can leverage our understanding of pointers to create a better design.\nIn the terminal, type code list.c and write code as follows:\n// Implements a list of numbers with an array of dynamic size #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void) { // List of size 3 int *list = malloc(3 * sizeof(int)); if (list == NULL) { return 1; } // Initialize list of size 3 with numbers list[0] = 1; list[1] = 2; list[2] = 3; // List of size 4 int *tmp = malloc(4 * sizeof(int)); if (tmp == NULL) { free(list); return 1; } // Copy list of size 3 into list of size 4 for (int i = 0; i \u0026lt; 3; i++) { tmp[i] = list[i]; } // Add number to list of size 4 tmp[3] = 4; // Free list of size 3 free(list); // Remember list of size 4 list = tmp; // Print list for (int i = 0; i \u0026lt; 4; i++) { printf(\u0026#34;%i\\n\u0026#34;, list[i]); } // Free list free(list); return 0; } Notice that a list of size three integers is created. Then, three memory addresses are assigned the values 1, 2, and 3. Then, a list of size four is created. Next, the list is copied from the first to the second. The value for the 4 is added to the tmp list. Since the block of memory that list points to is no longer used, it is freed using the command free(list). Finally, the compiler is told to point list pointer now to the block of memory that tmp points to. The contents of list are printed and then freed.\n"
},
{
	"uri": "//localhost:1313/4-linked-lists/",
	"title": "Linked Lists",
	"tags": [],
	"description": "",
	"content": "A linked list is one of the most powerful data structures within C. A linked list allows us to include values that are located at varying areas of memory. Further, they allow us to dynamically grow and shrink the list as we desire.\nWe will use following primitives:\nstruct is a data type that we can define ourselves. . allows us to access variables inside that structure. * operator is used to declare a pointer or dereference a variable. -\u0026gt; operator goes to an address and looks inside of a structure. Imagine three values stored at three different areas of memory as follows:\nTo stitch together these values in a list, we could utilize more memory to keep track of where the next item is.\nNULL is used to indicate that nothing else is next in the list.\nBy convention, we would keep one more element in memory, a pointer, that keeps track of the first item in the list.\nAbstracting away the memory addresses, the list would appear as follows:\nThese boxes are called nodes. A node contains both an *item* and a pointer called *next*. In code, we can imagine a node as follows:\ntypedef struct node { int number; struct node *next; } node; The item contained within this node is an integer called number. Second, a pointer to a node called next is included, which will point to another node somewhere in memory.\nConceptually, we can imagine the process of creating a linked list. First, node *list is declared, but it is of a garbage value.\nNext, a node called n is allocated in memory.\nNext, the number of node n is assigned the value 1.\nNext, the node’s next field is assigned NULL.\nNext, list is pointed at the memory location to where n points. n and list now point to the same place.\nA new node is then created. Both the number and next field are both filled with garbage values.\nThe number value of n’s node (the new node) is updated to 2.\nAlso, the next field is updated as well.\nMost important, we do not want to lose our connection to any of these nodes lest they be lost forever. Accordingly, n’s next field is pointed to the same memory location as list.\nFinally, list is updated to point at n. We now have a linked list of two items.\nTo implement this in code, write code list.c as follows:\n// Implements a list of numbers using a linked list #include \u0026lt;cs50.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct node { int number; struct node *next; } node; int main(int argc, char *argv[]) { // Memory for numbers node *list = NULL; // For each command-line argument for (int i = 1; i \u0026lt; argc; i++) { // Convert argument to int int number = atoi(argv[i]); // Allocate node for number node *n = malloc(sizeof(node)); if (n == NULL) { return 1; } n-\u0026gt;number = number; n-\u0026gt;next = NULL; // If list is empty if (list == NULL) { // This node is the whole list list = n; } // If list has numbers already else { // Iterate over nodes in list for (node *ptr = list; ptr != NULL; ptr = ptr-\u0026gt;next) { // If at end of list if (ptr-\u0026gt;next == NULL) { // Append node ptr-\u0026gt;next = n; break; } } } } // Print numbers for (node *ptr = list; ptr != NULL; ptr = ptr-\u0026gt;next) { printf(\u0026#34;%i\\n\u0026#34;, ptr-\u0026gt;number); } // Free memory node *ptr = list; while (ptr != NULL) { node *next = ptr-\u0026gt;next; free(ptr); ptr = next; } } Notice that what the user inputs at the command line is put into the number field of a node called n, and then that node is added to the list. For example, ./list 1 2 will put the number 1 into the number field of a node called n, then put a pointer to list into the next field of the node, and then update list to point to n. That same process is repeated for 2. Next, node *ptr = list creates a temporary variable that points at the same spot that list points to. The while prints what at the node ptr points to, and then updates ptr to point to the next node in the list. Finally, all the memory is freed.\nLinked lists are not stored in a contiguous block of memory. They can grow as large as you wish, provided that enough system resources exist. The downside, however, is that more memory is required to keep track of the list instead of an array. This is because for each element, we must store not just the value of the element, but also a pointer to the next node.\nFurther, linked lists cannot be indexed into like is possible in an array because we need to pass through the first n−1 elements to find the location of the n element. Because of this, the list pictured above must be linearly searched, binary search is not possible.\nWe can create a list that is sorted when items are added:\n// Implements a sorted list of numbers using a linked list #include \u0026lt;cs50.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct node { int number; struct node *next; } node; int main(int argc, char *argv[]) { // Memory for numbers node *list = NULL; // For each command-line argument for (int i = 1; i \u0026lt; argc; i++) { // Convert argument to int int number = atoi(argv[i]); // Allocate node for number node *n = malloc(sizeof(node)); if (n == NULL) { return 1; } n-\u0026gt;number = number; n-\u0026gt;next = NULL; // If list is empty if (list == NULL) { list = n; } // If number belongs at beginning of list else if (n-\u0026gt;number \u0026lt; list-\u0026gt;number) { n-\u0026gt;next = list; list = n; } // If number belongs later in list else { // Iterate over nodes in list for (node *ptr = list; ptr != NULL; ptr = ptr-\u0026gt;next) { // If at end of list if (ptr-\u0026gt;next == NULL) { // Append node ptr-\u0026gt;next = n; break; } // If in middle of list if (n-\u0026gt;number \u0026lt; ptr-\u0026gt;next-\u0026gt;number) { n-\u0026gt;next = ptr-\u0026gt;next; ptr-\u0026gt;next = n; break; } } } } // Print numbers for (node *ptr = list; ptr != NULL; ptr = ptr-\u0026gt;next) { printf(\u0026#34;%i\\n\u0026#34;, ptr-\u0026gt;number); } // Free memory node *ptr = list; while (ptr != NULL) { node *next = ptr-\u0026gt;next; free(ptr); ptr = next; } } "
},
{
	"uri": "//localhost:1313/5-trees/",
	"title": "Trees",
	"tags": [],
	"description": "",
	"content": "Binary search trees are another data structure that can be used to store data more efficiently such that it can be searched and retrieved.\nWe can imagine a sorted sequence of numbers.\nImagine then that the center value becomes the top of a tree. Those that are less than this value are placed to the left. Those values that are more than this value are to the right.\nPointers can then be used to point to the correct location of each area of memory such that each of these nodes can be connected.\nIn code, this can be implemented as follows.\n// Implements a list of numbers as a binary search tree #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // Represents a node typedef struct node { int number; struct node *left; struct node *right; } node; void free_tree(node *root); void print_tree(node *root); int main(void) { // Tree of size 0 node *tree = NULL; // Add number to list node *n = malloc(sizeof(node)); if (n == NULL) { return 1; } n-\u0026gt;number = 2; n-\u0026gt;left = NULL; n-\u0026gt;right = NULL; tree = n; // Add number to list n = malloc(sizeof(node)); if (n == NULL) { free_tree(tree); return 1; } n-\u0026gt;number = 1; n-\u0026gt;left = NULL; n-\u0026gt;right = NULL; tree-\u0026gt;left = n; // Add number to list n = malloc(sizeof(node)); if (n == NULL) { free_tree(tree); return 1; } n-\u0026gt;number = 3; n-\u0026gt;left = NULL; n-\u0026gt;right = NULL; tree-\u0026gt;right = n; // Print tree print_tree(tree); // Free tree free_tree(tree); return 0; } void free_tree(node *root) { if (root == NULL) { return; } free_tree(root-\u0026gt;left); free_tree(root-\u0026gt;right); free(root); } void print_tree(node *root) { if (root == NULL) { return; } print_tree(root-\u0026gt;left); printf(\u0026#34;%i\\n\u0026#34;, root-\u0026gt;number); print_tree(root-\u0026gt;right); } Notice this search function begins by going to the location of tree. Then, it uses recursion to search for number. The free_tree function recursively frees the tree. print_tree recursively prints the tree.\nA tree like the above offers dynamism that an array does not offer. It can grow and shrink as we wish.\nFurther, this structure offers a quick search time.\n"
},
{
	"uri": "//localhost:1313/6-dictionaries/",
	"title": "Dictionaries",
	"tags": [],
	"description": "",
	"content": "Dictionaries Dictionaries are another data structure. Dictionaries essentially, like actual book-form dictionaries that have a word and a definition, have a key and a value.\nKeys can often be of various types (strings, numbers, etc.), and values can be of any data type. Each key is unique and is used to retrieve the associated value efficiently.\nDictionaries can offer such speed of access through hashing.\nHashing Hashing is the idea of taking a value and being able to output a value that becomes a shortcut to it later.\nFor example, hashing *apple* may hash as a value of 1, and *berry* may be hashed as 2. Therefore, finding *apple* is as easy as asking the *hash* algorithm where 1 is stored. A hashed value can be used to shortcut finding such a value.\nA hash function is an algorithm that reduces a larger value to something small and predictable. Generally, this function takes in an item we wish to add to the hash table, and returns an integer representing the array index in which the item should be placed.\nA hash table is a combination of both arrays and linked lists. When implemented in code, a hash table is an array of pointers to nodes.\nA hash table could be imagined as follows:\nNotice that this is an array that is assigned each value of the alphabet.\nThen, at each location of the array, a linked list is used to track each value being stored there:\nCollisions are when we add values to the hash table, and something already exists at the hashed location. In the above, collisions are simply appended to the end of the list.\nCollisions can be reduced by better programming the hash table and hash algorithm. Imagine an improvement upon the above as follows:\nWe have to make a decision about the advantages of using more memory to have a large hash table and potentially reducing search time or using less memory and potentially increasing search time.\n"
},
{
	"uri": "//localhost:1313/7-tries/",
	"title": "Tries",
	"tags": [],
	"description": "",
	"content": "Tries are another form of data structure used for storing a dynamic set of strings. Tries are always searchable in constant time. It\u0026rsquo;s particularly efficient for tasks like prefix searching and autocomplete. One downside to Tries is that they tend to take up a large amount of memory.\nToad would be stored as follows:\nToad being spelled with one letter at a time where one letter is associated with one list T from one list O from another and so on.\nNotice that we need 26 x 4 = 104 nodes just to store Toad\nAnd that’s the end of week 5 ^^\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]